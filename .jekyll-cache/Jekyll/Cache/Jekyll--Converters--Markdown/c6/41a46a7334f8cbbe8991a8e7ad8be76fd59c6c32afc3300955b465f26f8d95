I"Á<h1 id="lifetimes">Lifetimes</h1>

<ul>
  <li>What Is a Lifetime?</li>
</ul>

<p>Lifetimes describes the scope that a reference is valid for.
Let‚Äôs look at a real-life analogy to explain this concept. You are the owner of a book, 
but you allow other people to use it for some time.</p>

<p><img src="https://raw.githubusercontent.com/sangam14/RustLabs/master/img/lifetime-ex.png" alt="" /></p>

<ul>
  <li>Let‚Äôs understand this concept in terms of memory management. Having a reference to a resource that someone else has the ownership of can be complicated.
For example, imagine this set of operations:
    <ul>
      <li>I have some kind of resource.</li>
      <li>I allow you to borrow the resource.</li>
      <li>I decide my task is completed with the resource, and I want to deallocate it, while you still have the reference of my resource.
  You still want to use the resource.</li>
    </ul>
  </li>
  <li>Now you are referencing a resource that is deallocated, an invalid resource. This is called a dangling pointer or use after free, when the resource is memory.</li>
  <li>To make sure that step four never happens, the concept of a lifetime comes into play!</li>
</ul>

<p>There are two cases to consider.</p>

<p>Case 1: When we know the lifetime of a variable by just looking at the program code</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#![allow(dead_code)] 
struct Course{
   name: String,
   id : i32,
}
fn main(){
  let c1:&amp;Course;
    {
    let c2: Course = Course {
      name : String::from("Rust"),
      id:101,
    };
    }
    c1 = &amp;c2; // allocated reference to a memory location that is dropped
}

</code></pre></div></div>

<p>The above example gives an error, ‚ùå, since c1 references c2 which is deallocated when the scope of c2 finishes.</p>

<p>It is implicit that the scope of c2 finishes and it cannot be used after line 13. But when there is a function that 
takes an argument by reference, we can be either implicit or explicit about the lifetime of the reference</p>

<p>Case 2: When we can‚Äôt say anything about the lifetime of a variable</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#![allow(dead_code)] 

struct Course{

   name: String,

   id : i32,

}

fn get_course(c1: &amp;Course, c2: &amp;Course)-&gt;&amp;Course{

  if c1.name == "Rust" {

     c1

  }

  else {

     c2

  }

}

fn main(){

  let c1: Course = Course {

      name : String::from("Rust"),

      id:101,

    };

    

   let c2: Course = Course {

      name : String::from("C++"),

      id:101,

    };

    get_course(c1, c2);   

}


</code></pre></div></div>

<p>The above code gives an error, ‚ùå, which says missing lifetime specifier. In the function definition,
c1 is referencing Course and c2 is referencing Course. What if this particular piece of memory is invalid? And for
how long does it remains valid? How can we ensure that the function is going to return a valid reference? The compiler is 
confused what the lifetime of the variable is. Solution: use the lifetime annotation.</p>

<h1 id="how-does-the-compiler-know-the-lifetime-of-a-variable">How does the compiler know the lifetime of a variable?</h1>
<ul>
  <li>Rust compiler has a borrow checker. It compares the scope of the reference variable and the variable<br />
being referred. It ensures that the variable being referred to lives as long as the variable referencing it.</li>
</ul>

<h2 id="lifetime-annotation">Lifetime Annotation</h2>

<ul>
  <li>It describes the lifetime of a reference.
    <ul>
      <li>Starts with an apostrophe</li>
      <li>Followed by a small case name, generally a single letter</li>
    </ul>
  </li>
</ul>

<h2 id="function-with-reference-variable-having-a-lifetime">Function With Reference Variable Having a Lifetime</h2>

<p><img src="https://raw.githubusercontent.com/sangam14/RustLabs/master/img/lifetime-ref-variable.png" alt="" /></p>

<h2 id="function-with-mutable-reference-variable-having-a-lifetime">Function With Mutable Reference Variable Having a Lifetime</h2>

<p><img src="https://raw.githubusercontent.com/sangam14/RustLabs/master/img/lifetime-mutable-variable.png" alt="" /></p>

<ul>
  <li>Example</li>
</ul>

<p>Now, coming back to the example in Case 2. The following code annotates the lifetime of variable c1, c2, and the return value.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#![allow(dead_code)] 

struct Course{

   name: String,

   id : i32,

}

fn get_course&lt;'a&gt; (c1: &amp;'a Course, c2: &amp;'a Course) -&gt; &amp;'a Course {

  if c1.name == "Rust" {

     c1

  }

  else {

     c2

  }

}

fn main(){

  let c1: Course = Course {

      name : String::from("Rust"),

      id:101,

    };

    

   let c2: Course = Course {

      name : String::from("C++"),

      id:101,

    };

    get_course(&amp;c1, &amp;c2);   

}



</code></pre></div></div>

<p>Here, lifetime annotation is used for parameter c1 and c2 meaning both parameters have the same lifetime as that of the function. Basically, it is trying to tell the compiler that there is a lifetime for which both of the references are valid and for the same lifetime the reference for the return type is also valid. Earlier the issue was that the time for which the return type was valid was unknown. Now, the borrow checker can check whether the reference is valid or not and gives us a 
compile-time error if it is invalid. Here, in this case, the reference is valid for ‚Äòa.</p>

<p>The lifetime annotation &lt;‚Äôa&gt; is basically a relationship. It is not used standalone. If you don‚Äôt write this, the code will
be correct syntactically, but the compiler will generate a compile-time error, ‚ùå.</p>

<ul>
  <li>How is ‚Äòa calculated?
    <ul>
      <li>‚Äòa refers to the lifetime in which all the references are valid, which is the overlap of the related lifetimes,
or the common lifetime of n number of instances. As a result, lifetime having the smallest reference of all references get assigned to ‚Äòa.</li>
    </ul>
  </li>
</ul>

<h2 id="multiple-lifetimes">Multiple Lifetimes</h2>

<p>There are two possibilities when the reference variables are used as function parameters:</p>

<h3 id="multiple-references-have-the-same-lifetime">Multiple references have the same lifetime</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn fun_name &lt;'a&gt;(x: &amp; 'a i32 , y: &amp; 'a i32) -&gt; &amp; 'a i32 
  // statements

</code></pre></div></div>
<p>Here, the variable x and y have the same lifetime ‚Äòa.</p>

<h3 id="multiple-references-have-different-lifetimes">Multiple references have different lifetimes</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn fun_name&lt;'a , 'b&gt;(x: &amp; 'a i32 , y: &amp; 'b i32) 
 // statements  
</code></pre></div></div>
<p>Here, both references x and y have different lifetimes. x has lifetime ‚Äòa and y has lifetime ‚Äòb.</p>

:ET