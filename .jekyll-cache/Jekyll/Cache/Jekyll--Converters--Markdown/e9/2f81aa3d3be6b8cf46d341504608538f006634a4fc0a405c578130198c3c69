I"N<h1 id="borrowing-and-dereferencing-operators">Borrowing and Dereferencing Operators</h1>

<h1 id="borrowing-operator">Borrowing Operator</h1>

<p>Borrowing means to reference the original data binding or to share the data.</p>

<p>References are just like pointers in C.</p>

<p>Two variables are involved in a borrowing relationship when the referenced variable holds a value that the referencing variable borrows. 
The referencing variable simply points to the memory location of the referenced variable.</p>

<p><img src="https://raw.githubusercontent.com/sangam14/RustLabs/master/img/mem_ref_var.png" alt="" /></p>

<p>The following illustration shows that operand 1 borrows the value of operand 2 using two types of operators:</p>

<p><img src="https://raw.githubusercontent.com/sangam14/RustLabs/master/img/operator_mem.png" alt="" /></p>

<h1 id="types">Types</h1>

<p>Borrowing can be of two types:</p>
<ul>
  <li>Shared borrowing</li>
  <li>A piece of data that is shared by single or multiple variables but it cannot be altered</li>
  <li>Mutable borrowing</li>
  <li>A piece of data that is shared and altered by a single variable (but the data is inaccessible to other variables at that time)</li>
  <li>The following table summarizes the function of these two types.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>operator</th>
      <th>operation</th>
      <th>explanation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Operand1 = &amp; Operand2<br /></td>
      <td>shared borrow</td>
      <td>operand 1 can read data of  another operand 2</td>
    </tr>
    <tr>
      <td>Operand1 = &amp; mut Operand2</td>
      <td>mutable borrow</td>
      <td>Operand 1 can read and alter data of another operand2</td>
    </tr>
  </tbody>
</table>

<h1 id="example">Example</h1>
<p>The following example shows a shared borrow and mutable borrow:</p>

<p><img src="https://raw.githubusercontent.com/sangam14/RustLabs/master/img/shared_mutable.png" alt="" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn main() {
    let x = 10;
    let mut y = 13;
    //immutable reference to a variable
    let a = &amp;x;
    println!("Value of a:{}", a); 
    println!("Value of x:{}", x); // x value remains the same since it is immutably borrowed
    //mutable reference to a variable
    let b = &amp;mut y;
    println!("Value of b:{}", b);
    println!("Value of y:{}", y); // y value is changed since it is mutably borrowed
}


</code></pre></div></div>
<p>output:-</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Value of a:10
Value of x:10
Value of b:13
Value of y:13
 
</code></pre></div></div>
<h1 id="dereferencing-operator">Dereferencing Operator</h1>

<p>Once you have a mutable reference to a variable, dereferencing is the term used to refer to changing the value of the referenced variable using its address stored in the referring variable.</p>

<p>The following illustration shows that operand 1 mutably borrows the value of operand 2 using &amp; mut and then operand 1 dereferences the value of operand 2 using the <code class="language-plaintext highlighter-rouge">* </code>operator:</p>

<p><img src="https://raw.githubusercontent.com/sangam14/RustLabs/master/img/derefrencing-op.png" alt="" /></p>

<h1 id="type">Type</h1>

<p>The following table shows the dereferencing operator <code class="language-plaintext highlighter-rouge">*</code> along with its function .</p>

<table>
  <thead>
    <tr>
      <th>operator</th>
      <th>operation</th>
      <th>explanation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>*Operand1 = Operand2<br /></td>
      <td>Dereferencing a value</td>
      <td><br />point to the value of a mutable borrow variable and can also <br /><br />update that variable value</td>
    </tr>
  </tbody>
</table>

<h1 id="example-1">Example</h1>
<p>The following example shows how to dereference a variable:</p>

<p><img src="https://raw.githubusercontent.com/sangam14/RustLabs/master/img/dereferencing.png" alt="" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
fn main() {
    //mutable reference to a variable
    let mut x = 10;
    println!("Value of x:{}", x);
    let a = &amp; mut x;
    println!("Value of a:{}", a);
    //dereference a variable
    *a = 11;
    println!("Value of a:{}", a);
    println!("Value of x:{}", x); // Note that value of x is updated
}


</code></pre></div></div>
<p>output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Value of x:10
Value of a:10
Value of a:11
Value of x:11

</code></pre></div></div>

<h1 id="quiz">Quiz</h1>

<p>Test your understanding of borrowing and dereferencing operators in Rust.</p>

<p>1.A variable can be updated through a dereference operator if itâ€™s a <br />
a) shared borrow <br />
b) mutable borrow <br /></p>

<ol>
  <li>What is the output of the following code?  <br /></li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
fn main() {
      let a = &amp;10;
      let b = &amp;mut 9;
      *b = 12;
      println!("Value of a:{}",a);
      println!("Value of b:{}",b);   
}


</code></pre></div></div>
<p>A) Value of a:10 <br />
   Value of b:12 <br /></p>

<p>B) Value of a:10 <br />
   Value of b:9 <br /></p>

:ET