I"¨"<h1 id="borrowing">Borrowing</h1>

<ul>
  <li>What is Borrowing? 
Borrowing, in simple terms, means to share.
Letâ€™s look at a real-life analogy to explain this concept. You are the owner of a book, but you allow other people to use it.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/sangam14/RustLabs/master/img/borrow-example.png" alt="" /></p>

<h1 id="types-of-borrowing">Types of Borrowing</h1>
<p>In Rust, borrowing can be of two types:</p>

<h2 id="shared-borrows">Shared Borrows</h2>

<p>The ownership belongs to the assignee variable but the assigned variable can only read the value.</p>
<ul>
  <li>Multiple variables can borrow the value of the variable at the same time.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/sangam14/RustLabs/master/img/SharedBorrows-1.png" alt="" /></p>

<h2 id="mutable-borrows">Mutable Borrows</h2>

<p>The ownership belongs to the assignee variable but the assigned variable can share as well as mutate the value of owner variable.</p>
<ul>
  <li>Only one variable in the scope can borrow mutably.
After the mutable borrow operation, the value of the mutably borrowed variable is moved to become inaccessible.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/sangam14/RustLabs/master/img/mutableBorrows-1.png" alt="" /></p>

<h2 id="rules-of-borrowing">Rules of Borrowing</h2>
<p>There are two rules to referencing or borrowing variables.</p>

<h2 id="rule-1">Rule 1</h2>
<p>There can be either one mutable borrow or any number of immutable borrows within the same scope.</p>
<ul>
  <li>
    <p>It is not possible to do a shared borrow as well as a mutable borrow operation simultaneously in the same scope. 
  If you want to do this in the same program code, then enclose a block of code within {}. In the inner block perform the shared borrow, 
  and in the outer block perform the mutable borrow. Vice versa, outer block perform the shared borrow, and in the inner block perform the mutable borrow.</p>
  </li>
  <li>
    <p>Example #</p>
  </li>
</ul>

<p>The following example explains rule 1.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/// cannot mutable borrow b since its already a shared borrow

/// mutable borrow a in outer scope and shared borrow in inner scope

fn main() {

  

  let mut a = 1; // mutable variable a is defined

  println!("variable `a` :{}", a);

  let b = 1;

  println!("variable `b` :{}", b);

  {



      let r1 = &amp;a; // no problem

      println!("variable `r1` references `a` in inner scope(SHARED BORROW(a)) :{}",r1);

      let r2 = &amp;a; // no problem

      println!("variable `r1` references `a` in inner scope(SHARED BORROW(a) :{}",r2);

      println!("r1:{}\nr2:{}", r1, r2);

      // r1 and r2 scope end here

  }

  

  let r3 = &amp;mut a; // no problem

  *r3 = 3;

  println!("variable `r1` references `a` in outer scope(MUTABLE BORROW(a) and derefernced it and changed value to 3) :{}",r3);

  let r4 = &amp;b;

  println!("variable `r3` references `b` in outer scope(SHARED BORROW(b)) :{}",r4);

  let r5 = &amp;b;

  println!("variable `r3` references `b` in outer scope(SHARED BORROW(b)) :{}",r5);

  println!("r3:{}\nr4:{}\nr5:{}", r3 , r4 , r5);

}


</code></pre></div></div>

<p>output</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>variable `a` :1
variable `b` :1
variable `r1` references `a` in inner scope(SHARED BORROW(a)) :1
variable `r1` references `a` in inner scope(SHARED BORROW(a) :1
r1:1
r2:1
variable `r1` references `a` in outer scope(MUTABLE BORROW(a) and derefernced it and changed value to 3) :3
variable `r3` references `b` in outer scope(SHARED BORROW(b)) :1
variable `r3` references `b` in outer scope(SHARED BORROW(b)) :1
r3:3
r4:1
r5:1


</code></pre></div></div>

<h2 id="rule--2">Rule  2</h2>
<p>References must always be valid.</p>
<ul>
  <li>
    <p>Cannot reference a value that is moved, i.e., a non-primitive data type.</p>
  </li>
  <li>
    <p>Example 
The following example explains rule 2.</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn main() {



  let a = String::from("Rust"); //variable a



  println!("This is a variable a: {}", a);



  let b = a; // moves value of a to b



  println!("Value of variable a is moved to b.\n b : {}", b);

  println!("Now a becomes invalid.Accessing a will give error");

  

  //let c = &amp;a;

  //println!("This is a variable c trying to access value a: {}", c);

}


</code></pre></div></div>
<p>output</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>This is a variable a: Rust
Value of variable a is moved to b.
 b : Rust
Now a becomes invalid.Accessing a will give error

</code></pre></div></div>

<h1 id="functions-and-borrowing">Functions and Borrowing</h1>

<p>Recall <a href="https://rustlabs.kubedaily.com/Beginners/Pass_by_Reference.html">pass by reference</a> in which &amp; mut was used as a function parameter when mutating values inside the function.</p>

<ul>
  <li>Example</li>
</ul>

<p>The following example declares a function example which takes an owner variable, shared borrow and a mutable borrow as arguments to the function.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 'a' an owner variable
// 'b' a shared borrow
// 'c' a mutable borrow
fn example(a: i32, b:&amp; i32,c : &amp;mut i32){
  println!("a: {}, b: {}, c: {}", a , b , c);
   *c=9;
}
fn main(){
   let a = 1;
   let b = 2;
   let mut c = 3;
   example( a, &amp;b , &amp;mut c);
   println!("a: {}, b: {}, c: {}", a , b , c);
}


</code></pre></div></div>

<p>output</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a: 1, b: 2, c: 3
a: 1, b: 2, c: 9

</code></pre></div></div>

<h2 id="borrowing-and-slicing">Borrowing and Slicing</h2>

<p>It is possible to borrow a slice of an array, vector or string. Recall the syntax of slicing. It used an &amp; before the name of the variable to be borrowed.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let arr:[i32;4] = [1, 2, 3, 4]; 
let borrow_a = &amp;arr[0..2];
 
let str=String::from("Rust Programming");
let borrow_str = &amp;str[0..2];
 
let my_vec = vec![1, 2, 3, 4, 5];
let borrow_vec = &amp;my_vec[0..2];


</code></pre></div></div>
<p>Here &amp; indicates a shared borrow.</p>

<h2 id="example">Example</h2>

<p>The following examples revise your concept of slicing in arrays, strings, and vectors respectively.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn main() {

  let arr:[i32;4] = [1, 2, 3, 4]; // define an array

  let borrow_arr = &amp;arr[0..2]; // slice an array



  println!("arr : {:?}", arr); // print the array

  println!("sliced_arr : {:?}", borrow_arr); // print the sliced array



  let str = String::from("Rust Programming"); // define a String object

  let borrow_str = &amp;str[0..2]; // slice the String object



  println!("str : {:?}", str); // print the String Object 

  println!("sliced_str : {:?}", borrow_str); // print the sliced String



  let my_vec = vec![1, 2, 3, 4, 5]; // define a vector

  let borrow_vec = &amp;my_vec[0..2]; // slice the vector

  

  println!("vec: {:?}", my_vec);  // print the vector

  println!("sliced_vec : {:?}", borrow_vec); // print the sliced vector

}


</code></pre></div></div>
<p>output</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>arr : [1, 2, 3, 4]
sliced_arr : [1, 2]
str : "Rust Programming"
sliced_str : "Ru"
vec: [1, 2, 3, 4, 5]
sliced_vec : [1, 2]

</code></pre></div></div>

<h1 id="quiz">Quiz</h1>

<p>Test your understanding of borrowing in Rust.</p>

<ol>
  <li>
    <p>Can a variable have a shared borrow or mutable borrow reference within the same scope? <b>
A) Yes <b>
B) No <b></b></b></b></p>
  </li>
  <li>
    <p>Why does this code give an error? <br /></p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn main() {
  let a = String::from("Rust"); 
  let b = a;
  let c = &amp;b;
  println!("println!{}", a);
}


</code></pre></div></div>
<p>A) Trying to print moved value a <br />
B) c borrows b <br /></p>

<ol>
  <li>Why does this code give an error? <br /></li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn main() {
  let a = String::from("Rust"); 
  let b = a;
  let c = &amp;a;
}


</code></pre></div></div>
<p>A) Variable c is making an invalid access <br />
B) Variable a is out of scope <br /></p>

:ET