I"š<h1 id="result-and-enum">Result and Enum</h1>

<ul>
  <li>What Is Result?</li>
</ul>

<p>Result is a built-in enum in the Rust standard library. It has two variants <code class="language-plaintext highlighter-rouge">Ok(T)</code> and <code class="language-plaintext highlighter-rouge">Err(E)</code>.</p>

<p><img src="https://raw.githubusercontent.com/sangam14/RustLabs/master/img/enum-result.png" alt="" /></p>

<ul>
  <li>Variants:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Ok(T)</code>, returns the success statement of type <code class="language-plaintext highlighter-rouge">T</code></li>
      <li><code class="language-plaintext highlighter-rouge">Err</code>, returns the error statement of type <code class="language-plaintext highlighter-rouge">E</code>.</li>
    </ul>
  </li>
  <li>When to Use Result?
    <ul>
      <li>Result should be used as a return type for a function that can encounter error situations. Such functions can return an
  Ok value in case of success or an Err value in case of an error.</li>
    </ul>
  </li>
  <li>Result and Function
    <ul>
      <li>Using Result as a function return type can be used to return various kinds of success and error codes to let the calling 
  function decode the execution state of the called function.</li>
    </ul>

    <p><img src="https://raw.githubusercontent.com/sangam14/RustLabs/master/img/enum-result1.png" alt="" /></p>
  </li>
</ul>

<h1 id="example-1">Example 1</h1>

<p>The following code has a function <code class="language-plaintext highlighter-rouge">file_found</code> which takes a number i and returns a Result of type i32, in case of variant Ok and bool, in case of Err.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn main() {
   println!("{:?}",file_found(true)); // invoke function by passing true 
   println!("{:?}",file_found(false)); // invoke function by passing false
}
fn file_found(i:bool) -&gt; Result&lt;i32,bool&gt; {
   if i { // if true
      Ok(200) // return Ok(200)
   } else { // if false
      Err(false) // return Err(false)
   }
}

</code></pre></div></div>

<p>output</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Ok(200)
Err(false)
</code></pre></div></div>

<p>Example 2 #</p>

<p>The following code has a function <code class="language-plaintext highlighter-rouge">divisible_by_3</code> which takes a number i and returns a Result of type String in case of both variants Ok and Err. 
If i is <code class="language-plaintext highlighter-rouge">divisible by 3 Ok(Given number is divisible by 3)</code> is returned and <code class="language-plaintext highlighter-rouge">Err(Given number is not divisible by 3)</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn main() {
   println!("{:?}", divisible_by_3(6)); // invoke function by passing a number 6
   println!("{:?}", divisible_by_3(2)); // invoke function by passing a number 2
}
fn divisible_by_3(i:i32)-&gt;Result&lt;String,String&gt; {
   if i % 3 == 0 { // if number mod 3 equals 0
      Ok("Given number is divisible by 3".to_string()) // return this statement
   } else { // if if number mod 3 is not equals 0
      Err("Given number is not divisible by 3".to_string()) // return this statement
   }
}


</code></pre></div></div>

<p>output</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Ok("Given number is divisible by 3")
Err("Given number is not divisible by 3")

</code></pre></div></div>

<h1 id="is_ok-is_err-functions"><code class="language-plaintext highlighter-rouge">is_ok()</code>, <code class="language-plaintext highlighter-rouge">is_err()</code> Functions</h1>

<p>Rust helps you to check whether the variable of type Result is set to Ok or Err.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn main() {
   let check1 = divisible_by_3(6);
   if check1.is_ok(){ // check if the function returns ok
      println!("The number is divisible by 3");
   }
   else{
      println!("The number is not divisible by 3");

   }
   let check2 = divisible_by_3(2);
   if check2.is_err(){ // check if the function returns error
      println!("The number is not divisible by 3");
   }
   else{
      println!("The number is divisible by 3");

   }
}
fn divisible_by_3(i:i32)-&gt;Result&lt;String,String&gt; {
   if i % 3 == 0 { // check i modulus 3
      Ok("Given number is divisible by 3".to_string())
   } else {
      Err("Given number is not divisible by 3".to_string())
   }
}


</code></pre></div></div>
<p>output</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The number is divisible by 3
The number is not divisible by 3

</code></pre></div></div>

<h1 id="example-2">Example 2</h1>

<p>The following example uses the assert_eq! macro to check whether the variable value of type Result is set to Ok or Err.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn main() {
   let check1 = divisible_by_3(6);
   assert_eq!(check1.is_ok(), true);  // left is true and right is true so the assertion passes
   let check2 = divisible_by_3(2);
   assert_eq!(check2.is_err(), true); // left is true and right is true so the assertion passes
}
fn divisible_by_3(i:i32)-&gt;Result&lt;String,String&gt; {
   if i % 3 == 0 {
      Ok("Given number is divisible by 3".to_string())
   } else {
      Err("Given number is not divisible by 3".to_string())
   }
}


</code></pre></div></div>

<p>Note: The assertion passes since the expression evaluates to true.</p>

:ET