I"
<h1 id="integers">Integers</h1>

<p>Variables of Integer data type hold whole number values. There are two subtypes of integer data type in Rust, based on the number of bits occupied by a variable in memory.</p>

<p><img src="https://raw.githubusercontent.com/sangam14/RustLabs/master/img/integer-type.png" alt="" /></p>

<h1 id="fixed-size-types">Fixed Size Types</h1>

<p>The fixed integer types have a specific number of bits in their notation. This notation is a combination of a letter and a number. The former denotes the category of the integer, whether it is, unsigned or signed, and the latter denotes the size of an integer, i.e., 8, 16, 32, 64.</p>

<ul>
  <li>
    <p>Below is the list of fixed length integer types:</p>

    <ul>
      <li>
        <p>i8: The 8-bit signed integer type.</p>
      </li>
      <li>
        <p>i16: The 16-bit signed integer type.</p>
      </li>
      <li>
        <p>i32: The 32-bit signed integer type.</p>
      </li>
      <li>
        <p>i64: The 64-bit signed integer type.</p>
      </li>
      <li>
        <p>u8: The 8-bit unsigned integer type.</p>
      </li>
      <li>
        <p>u16: The 16-bit unsigned integer type.</p>
      </li>
      <li>
        <p>u32: The 32-bit unsigned integer type.</p>
      </li>
      <li>
        <p>u64: The 64-bit unsigned integer type.</p>
      </li>
    </ul>
  </li>
</ul>

<h1 id="variable-size-types">Variable Size Types</h1>

<p>The integer type in which the particular size depends on the underlying machine architecture.</p>

<p><img src="https://raw.githubusercontent.com/sangam14/RustLabs/master/img/integer-size.png" alt="" />
<br /></p>

<p>ðŸ’¡ Why are there so many types of integers and how do you pick a data type?
The choice depends on what values a variable is expected to hold. So, a programmer should pick a data type that is not so small that the data is lost. Nor should they pick a data type that is so big that it wastes memory.</p>

<p>isize: The pointer-sized signed integer type.
usize: The pointer-sized unsigned integer type</p>

<h1 id="example">Example</h1>

<p>The code below defines an integer type both explicitly and implicitly:</p>

<ul>
  <li>Explicit Definition</li>
</ul>

<p>The following code explicitly defines the integer variables using the integer type fixed or variable):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
fn main() {
    //explicitly define an integer
    let a:i32 = 24;
    let b:u64 = 23;
    let c:usize = 26;
    let d:isize = 29;
    //print the values
    println!("a: {}", a);
    println!("b: {}", b);
    println!("c: {}", c);
    println!("d: {}", d);
    
}

</code></pre></div></div>

<p>Output</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a: 24
b: 23
c: 26
d: 29

</code></pre></div></div>

<h1 id="implicit-definition">Implicit Definition</h1>

<p>The following code implicitly defines the integer type of the variable by assigning an integer value to the variable.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
fn main() {
    //explicitly define an integer
    let a = 21; 
    let b = 1;
    let c = 54;
    let d = 343434;
    //print the variable
    println!("a: {}", a);
    println!("b: {}", b);
    println!("c: {}", c);
    println!("d: {}", d);
    
}

</code></pre></div></div>
<p>Output</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a: 21
b: 1
c: 54
d: 343434

</code></pre></div></div>

<h1 id="floating-point">Floating Point</h1>

<p>Floating-point numbers refer to numbers with a fractional part.</p>

<p>The representation of floating-point numbers in a computerâ€™s memory is such that the precision with which a number is stored in memory depends on the number of bits used for storing the variable.</p>

<p>In this respect, there are two subtypes: single-precision f32 and double-precision f64 floating-point, with the latter having more bits to store the number.</p>

<p><img src="https://raw.githubusercontent.com/sangam14/RustLabs/master/img/f-size.png" alt="" /></p>

<ul>
  <li>f32: The 32-bit floating point type.</li>
  <li>f64: The 64-bit floating point type.</li>
</ul>

<h1 id="example-1">Example</h1>

<p>The code below defines a floating-point number both explicitly and implicitly:</p>
<ul>
  <li>Explicit Definition</li>
</ul>

<p>The following code explicitly defines the float variable using the float type (f32 or f64)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn main() {
    //explicitly define a float type
    let f1:f32 = 32.9;
    let f2:f64 = 6789.89;
    println!("f1: {}", f1);
    println!("f2: {}", f2);
}


</code></pre></div></div>

<p>Output</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f1: 32.9
f2: 6789.89
</code></pre></div></div>

<h1 id="implicit-definition-1">Implicit Definition</h1>

<p>The following code implicitly defines the float type of the variable by assigning a floating-point value to the variable:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn main() {
    //implicitly define a float type
    let pi = 3.14;
    let e = 2.17828;
    println!("pi: {}", pi);
    println!("e: {}", e);
}

</code></pre></div></div>
<p>Output</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pi: 3.14
e: 2.17828
</code></pre></div></div>

<h1 id="quiz">Quiz</h1>

<p>Test your understanding of Numeric Types in Rust!</p>

<ol>
  <li>What is the data type of the variable below? <br />
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let  a = 123;
</code></pre></div>    </div>
    <p>a) Integer <br /> 
b) Float  <br /></p>
  </li>
  <li>Which of the following is an incorrect notation to declare a float type variable? <br /> 
a) f32 <br /> 
b) f64 <br /> 
c) f128 <br /></li>
</ol>

:ET