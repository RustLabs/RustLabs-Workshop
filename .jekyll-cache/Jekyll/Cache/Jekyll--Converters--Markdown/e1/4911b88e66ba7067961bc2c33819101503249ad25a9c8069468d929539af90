I"<<h1 id="tuple-structs">Tuple Structs</h1>

<p>What Are Tuple Structs?</p>
<ul>
  <li>Tuple Structs are a data type that is a hybrid between a tuple and a struct.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/sangam14/RustLabs/master/img/tuple-struct-ex1.png" alt="" /></p>

<p>Why a tuple struct?</p>

<p>In the example above, when it is only a tuple we donâ€™t know explicitly what each item in the tuple means. But when it is a tuple struct, we can assign a
name to each item.</p>

<p># Define a Tuple Struct</p>
<ul>
  <li>Tuples can be of type struct by adding the struct keyword before the tuple name, followed by the data type of the variables enclosed within round brackets.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/sangam14/RustLabs/master/img/tuple-struct-syntax.png" alt="" /></p>

<h1 id="initialize-a-tuple-struct">Initialize a Tuple Struct</h1>
<p>A tuple struct can be initialized like a tuple.</p>

<p><img src="https://raw.githubusercontent.com/sangam14/RustLabs/master/img/tuple-struct-init.png" alt="" /></p>

<h1 id="access-a-tuple-struct">Access a Tuple Struct</h1>
<p>The tuple struct can be accessed using a <code class="language-plaintext highlighter-rouge">.</code> operator like a traditional struct.</p>

<p><img src="https://raw.githubusercontent.com/sangam14/RustLabs/master/img/tuple-struct-access.png" alt="" /></p>

<h1 id="example">Example</h1>
<p>The following example declares a tuple struct named FruitQuantity.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//define a tuple struct
struct FruitQuantity(String, i32);
// main function
fn main() {
    // create an instance
    let r1 = FruitQuantity("oranges".to_string(), 12);
    // access values of a tuple struct
    println!("r1--name:{} quantity:{}", r1.0, r1.1);
    // create an instance
    let r2 = FruitQuantity("mangoes".to_string(), 13);
    // access values of a tuple struct
    println!("r2--name:{} quantity:{}", r2.0, r2.1);   
}


</code></pre></div></div>

<p>output</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>r1--name:oranges quantity:12
r2--name:mangoes quantity:13

</code></pre></div></div>

<p>main.rs</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#[allow(unused_variables, unused_mut)]
use std::fs::File;
use std::io::{BufRead, BufReader};
 
fn main() {
   let filename = "sublist_input.txt";
   // Open the file in read-only mode (ignoring errors).
   let file = File::open(filename).unwrap();
   let reader = BufReader::new(file);
   let mut vec1 = vec![];
   let mut vec2 = vec![];
   // Read the file line by line using the lines() iterator from std::io::BufRead.
   for (index, line) in reader.lines().enumerate() {
       let line = line.unwrap(); // Ignore errors.
       // Show the line and its number.
       println!("{}", line.to_string());
       let mystr = line.to_string();
       let bar: Vec&lt;&amp;str&gt; = mystr.split(", ").collect();
       let baz = bar.iter().map(|x| x.parse::&lt;i64&gt;());

       for x in baz {
           match x {
               Ok(i) =&gt; if index % 2 == 0 {vec1.push(i)} else {vec2.push(i)},
               Err(_) =&gt; println!("parse failed {:?}", x),
           }
       }
       if index % 2 == 1{
        println!("vec 1{:?}", vec1);  
        println!("vec 2{:?}", vec2);   
   
        println!("{}", Comparison::Superlist == sublist(&amp;vec1, &amp;vec1));
        println!("{}", Comparison::Equal == sublist(&amp;vec1, &amp;vec1));
        println!("{}", Comparison::Superlist == sublist(&amp;vec2, &amp;vec1));
        println!("{}", Comparison::Sublist == sublist(&amp;vec1, &amp;vec2));
        println!("{}", Comparison::Unequal == sublist(&amp;[1, 2, 1, 2, 3], &amp;[1, 2, 3, 1, 2, 3, 2, 3, 2, 1]));
       }

}
}


#[derive(Debug, PartialEq, Eq)]
enum Comparison {
    Equal,
    Sublist,
    Superlist,
    Unequal,
}


fn sublist(a : &amp;[i64], b : &amp;[i64]) -&gt; Comparison {
    if a == b {
        Comparison::Equal
    } else if contains(a, b) {
        Comparison::Superlist
    } else if contains(b, a) {
        Comparison::Sublist
    } else {
        Comparison::Unequal
    }
}

fn contains(a: &amp;[i64], b: &amp;[i64]) -&gt; bool {
    if a.len() &lt; b.len() {
        return false;
    }

    if a.starts_with(b) {
        return true;
    }

    contains(&amp;a[1..], b)
}




</code></pre></div></div>
<p>sublist_input.txt</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3, 4, 5
1, 2, 3, 4, 5


</code></pre></div></div>
<p>output</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3, 4, 5
1, 2, 3, 4, 5
vec 1[3, 4, 5]
vec 2[1, 2, 3, 4, 5]
false
true
true
true
true



</code></pre></div></div>

:ET