I"Š<h1 id="lifetime-elision">Lifetime Elision</h1>

<ul>
  <li>What Is Lifetime Elision?</li>
</ul>

<p>Some common coding patterns were identified and annotating them was an extra effort. 
In order to avoid that overhead, Rust allows lifetimes to be elided or omitted. This is known as lifetime elision.
Rust does so by designing rules for omitting lifetime annotation. They are tested at compile time and are used to determine a lifetime.</p>

<ul>
  <li>Lifetime Ellison can appear in two ways:
    <ul>
      <li>An input lifetime is a lifetime associated with a parameter of a function.
 ```
  fn fun_name&lt;â€™a&gt;( x : &amp; â€˜a i32);</li>
    </ul>

    <p>```
 Here, the input lifetime of x is â€˜a.</p>
  </li>
  <li>An output lifetime is a lifetime associated with the return value of a function.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> fn fun_name&lt;'a&gt;() -&gt; &amp; 'a i32;  
</code></pre></div></div>
<p>Here, the output lifetime of return value is â€˜a.</p>

<p>Note: A function can have both input and output lifetimes.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Note: A function can have both input and output lifetimes.

</code></pre></div></div>
<p>Here, the x has the input lifetime and the return value has the output lifetime.</p>

<h1 id="rules-for-elision">Rules for Elision</h1>

<h2 id="rule-1">Rule 1</h2>

<p>Each input parameter gets its own lifetime. If the lifetime is not specified, then the lifetime of each parameter is different.</p>

<ul>
  <li>Elided lifetime:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn fun_name( x: &amp;i32, y: &amp;i32){ 
} 

</code></pre></div></div>
<ul>
  <li>Expanded form:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn fun_name&lt;'a,'b&gt;( x :&amp; 'a i32, y : &amp; 'b i32){
}

</code></pre></div></div>
<h2 id="rule-2">Rule 2</h2>
<p>If there is only one input parameter, its lifetime is assigned to all the elided output lifetimes.</p>
<ul>
  <li>Elided lifetime:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn fun_name(x: i32) -&gt; &amp;i32{
}

</code></pre></div></div>
<ul>
  <li>Expanded form:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn fun&lt;'a&gt;(x: i32) -&gt; &amp; 'a i32 {
}

</code></pre></div></div>
<h2 id="rule-3">Rule 3</h2>

<p>If there are multiple input lifetimes, one of them is <code class="language-plaintext highlighter-rouge">&amp;self</code> or <code class="language-plaintext highlighter-rouge">&amp;mut self</code>, the lifetime of self is assigned to all elided output lifetimes.</p>

<ul>
  <li>Elided lifetime:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn fun_name(&amp;self, x : &amp;str) -&gt; &amp; str {
}

</code></pre></div></div>
<ul>
  <li>Expanded form:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn fun_name&lt;'a,'b&gt;(&amp; 'a self, x : &amp; 'b str) -&gt; &amp; 'a str {
}

</code></pre></div></div>
<p>Note: If the compiler canâ€™t infer the lifetime, it throws an error.</p>

:ET