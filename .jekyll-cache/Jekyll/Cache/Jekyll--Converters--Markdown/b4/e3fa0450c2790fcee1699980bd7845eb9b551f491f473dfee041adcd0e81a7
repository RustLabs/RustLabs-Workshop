I"©<h1 id="what-is-option">What Is Option?</h1>

<p>Option is a built-in enum in the Rust standard library. It has two variants Some and None.
<img src="https://raw.githubusercontent.com/sangam14/RustLabs/master/img/enum-option.png" alt="" /></p>

<ul>
  <li>Variants:
    <ul>
      <li>Some(T), returns Some value T</li>
      <li>None, returns no value</li>
    </ul>
  </li>
</ul>

<h1 id="when-to-use-option">When to Use Option?</h1>

<ul>
  <li>Options is a good choice when:
    <ul>
      <li>The return value is none
        <ul>
          <li>Rust avoids including nulls in the language, unlike other languages. For instance, the function that returns a value may actually return nothing. So, here the Option variant None comes in handy.</li>
        </ul>
      </li>
      <li>The value of the variable is optional
        <ul>
          <li>The value of any variable can be set to some value or set to none.</li>
        </ul>
      </li>
      <li>Out of bound exception is to be displayed
        <ul>
          <li>This is useful in the case of an array, string or a vector when an invalid index number tries to access it.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="example-1-return-value-is-none">Example 1: Return Value Is None</h1>

<p>The following example shows that if the else construct has no value then it can simply return None.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn main() {

   println!("{:?}", learn_lang("Rust"));

   println!("{:?}", learn_lang("Python"));

}

fn learn_lang(my_lang:&amp;str)-&gt; Option&lt;bool&gt; {

   if my_lang == "Rust" {

      Some(true)

   } else {

      None

   }

}


</code></pre></div></div>

<p>output</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Some(true)
None

</code></pre></div></div>
<p>Note: None does not take a parameter unlike Some.</p>

<h1 id="example-2-optional-variable-value">Example 2: Optional Variable Value</h1>

<p>The following example makes level variable of the struct Course as Option of type String. That means that itâ€™s optional
to set any value to it. It can be set to some value or it can be set to none.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//declare a struct
struct Course {
   code:i32,
   name:String,
   level: Option&lt;String&gt;, 
}
fn main() {
   //initialize
   let course1 = Course  {
      name:String::from("Rust"),
      level:Some(String::from("beginner")),
      code:130
   };
   let course2 = Course  {
      name:String::from("Javascript"),
      level:None,
      code:122
   };
   //access
   println!("Name:{}, Level:{} ,code: {}", course1.name, course1.level.unwrap_or("Level".to_string()), course1.code);
   println!("Name:{}, Level:{} ,code: {}", course2.name, course2.level.unwrap_or("No level defined!".to_string()), course2.code);
}

</code></pre></div></div>

<p>output</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Name:Rust, Level:beginner ,code: 130
Name:Javascript, Level:No level defined! ,code: 12

</code></pre></div></div>

<h1 id="example-3-index-out-of-bound-exception">Example 3: Index Out of Bound Exception</h1>

<p>The example below uses a match statement that takes an index of string
using <code class="language-plaintext highlighter-rouge">match.str.chars().nth(index_no)</code> and executes the Some block if <code class="language-plaintext highlighter-rouge">index_no</code> is in range and None block otherwise.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn main() {

  // define a variable

  let str = String :: from("Educative");

  // define the index value to be found

  let index = 12;

  lookup(str, index);

}

fn lookup(str: String, index: usize) {

  let matched_index = match str.chars().nth(index){

    // execute if match found print the value at specified index 

     Some(c)=&gt;c.to_string(),

     // execute if value not found

     None=&gt;"No character at given index".to_string()

     };  

  println!("{}", matched_index);

}



</code></pre></div></div>
<p>output</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>No character at given index

</code></pre></div></div>

<h1 id="is_some-is_none-functions"><code class="language-plaintext highlighter-rouge">is_some()</code>, <code class="language-plaintext highlighter-rouge">is_none()</code> Functions</h1>

<p>Rust provides <code class="language-plaintext highlighter-rouge">is_some()</code> and <code class="language-plaintext highlighter-rouge">is_none()</code> to identify the return type of variable of type Option, i.e., whether the value of type Option is set to Some or None.</p>

<h1 id="example-1">Example 1</h1>
<p>The following example checks whether the variable value of type Option is set to Some or None.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn main() {
    let my_val: Option&lt;&amp;str&gt; = Some("Rust Programming!");
    print(my_val); // invoke the function
   
}
fn print(my_val: Option&lt;&amp;str&gt;){
     if my_val.is_some(){ // check if the value is equal to some value
        println!("my_val is equal to some value");
    }
    else{
        println!("my_val is equal to none");
    }
}

</code></pre></div></div>
<p>output</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>my_val is equal to some value


</code></pre></div></div>

<p>We need to do is to ensure that these functions return true or false. Thatâ€™s where <code class="language-plaintext highlighter-rouge">assert_eq</code> and <code class="language-plaintext highlighter-rouge">assert_ne</code> functions come in handy.</p>

<ul>
  <li>Assert Macros
    <ul>
      <li><code class="language-plaintext highlighter-rouge">assert_eq!(left, right)</code> - evaluates to true if left value is equal to that of right</li>
      <li><code class="language-plaintext highlighter-rouge">assert_ne!(left, right)</code> - evaluates to true if left value is not equal to that of right</li>
    </ul>
  </li>
</ul>

<h1 id="output-of-assert-expression">Output of assert expression?</h1>
<ul>
  <li>If the assertion passes no output is displayed, and if doesnâ€™t the code gives an error saying that the assertion failed</li>
</ul>

<h1 id="example-2">Example 2</h1>

<p>The following example uses the <code class="language-plaintext highlighter-rouge">assert_eq!</code> macro to check whether the variable value of type Option is set to Some or None.</p>

<p>Note: The assertion passes since the expression evaluates to true.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fn main() {
    let my_val: Option&lt;&amp;str&gt; = Some("Rust Programming!");
    // pass since my_val is set to some value so left is true, and right is also true
    assert_eq!(my_val.is_some(), true); 
    // pass since my_val is set to some value so left is false, and right is also false
    assert_eq!(my_val.is_none(), false);
}

</code></pre></div></div>

:ET